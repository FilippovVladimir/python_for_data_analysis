# Лабораторная работа №2
**Предмет:** язык Python для анализа данных  
**ФИО:** Филиппов Владимир Леонидович   
**Группа:** K3339   
**ИСУ:** 292209

## Цель работы
- Научиться работать с NumPy-массивами.
- Закрепить срезы, оси, broadcasting и простые операции над массивами.
- Понять разницу между циклами Python и векторизацией NumPy на примере kNN.

## Используемые библиотеки
- numpy
- matplotlib
- (опционально) pillow для чтения изображения

## Часть 1 - Изображение как NumPy-массив

### Исходные данные
- Изображение загружается из файла `image.jpg`.
- Если файла нет или Pillow не установлен, создается случайный массив `uint8` формы (H, W, 3).

### 1) Форма массива изображения
- Цветное изображение в NumPy имеет форму:
  - (H, W, 3)
- Где:
  - H - высота
  - W - ширина
  - 3 - каналы RGB (красный, зеленый, синий)

### 2) Задание 2.1 - Выделение каналов
- Созданы 3 массива:
  - только красный канал (G=0, B=0)
  - только зеленый канал (R=0, B=0)
  - только синий канал (R=0, G=0)
- Результаты выводятся через `plt.imshow()`.

### 3) Задание 3.1 - Grayscale
- Использована формула:
  - gray = 0.299*R + 0.587*G + 0.114*B
- Результат приведен к типу `uint8` и показан как серое изображение.

### 4) Задание 4.1 - Уменьшение в 2 раза
- Применен срез:
  - small = img[::2, ::2]
- Это простой даунсэмплинг (берем каждый второй пиксель).

### 5) Задание 5.1 - Затирание прямоугольника
- Выбран прямоугольник по координатам:
  - y1:y2 и x1:x2
- Пиксели в области заменены на черный цвет [0, 0, 0].

### 6) Задание 6.1-6.3 - Перевороты и поворот
- Горизонтальный переворот:
  - np.flip(img, axis=1)
- Вертикальный переворот:
  - np.flip(img, axis=0)
- Поворот на 180:
  - np.flip(img, axis=(0, 1))

### 7) Задание 7.1 - Broadcasting (сделать "теплее")
- Создан фильтр:
  - filter = [50, 0, 0]
- Прибавлен к изображению (broadcasting по последней оси).
- Применен `np.clip` для ограничения 0..255.

### 8) Задание 8.1 - Градиентная маска
- Создан градиент по высоте:
  - gradient формы (H, 1, 1)
- Смешаны два изображения:
  - оригинал и инверсия (255 - img)
- Получен плавный переход сверху вниз.

## Часть 2 - kNN: чистый Python и NumPy

### Подготовка данных
- Генерируется обучающая выборка X размера (n, 3) из нормального распределения.
- Метки классов y создаются правилом:
  - класс 1, если сумма координат > 0, иначе класс 0

### Реализация 1 - чистый Python
- Расстояния считаются циклом по всем точкам и по всем координатам.
- Используется сортировка списка расстояний.
- Берутся k ближайших и выполняется голосование.

### Реализация 2 - NumPy
- Расстояния считаются векторно:
  - np.linalg.norm(X_train - x_test, axis=1)
- Индексы ближайших:
  - np.argsort(dists)[:k]
- Голосование:
  - среднее по меткам k соседей.

### Анализ результатов
- NumPy вариант работает быстрее, так как использует векторные операции и вычисляет расстояния без циклов Python.
- Чувствительность к k:
  - при малом k (например 1) результат более "шумный" и может меняться от выбросов
  - при большем k результат стабильнее, но может "сглаживать" границы классов

### Масштабирование
- При увеличении n (1000 -> 10000 -> 100000) время чистого Python растет очень сильно.
- NumPy растет медленнее и остается пригодным для больших n.

## Вывод
- NumPy удобен для работы с массивами и изображениями.
- Broadcasting позволяет менять каналы простыми операциями без циклов.
- Векторизация NumPy дает заметный выигрыш по времени по сравнению с циклами Python, особенно на больших данных.
